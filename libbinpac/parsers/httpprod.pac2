module HTTPProd;

import BinPAC;

import "BINPAC-HILTI-C" void set_uri(method: bytes, uri: bytes);
import "BINPAC-HILTI-C" void set_host(host: bytes);

type DeliveryMode = enum { EndOfData, Length, Multipart, Chunked };

const Token      = /[^ \t\r\n]+/;
const URI        = /[^ \t\r\n]+/;
const NewLine    = /\r?\n/;
const RestOfLine = /[^\r\n]*/;
const FullLine   = /[^\r\n]*\r?\n/;
const Integer    = /[0-9]+/;
const HexInteger = /[0-9a-zA-Z]+/;
const WhiteSpace = /[ \t]+/;
const OptionalWhiteSpace = /[ \t]*/;

bool reply_code_needs_body(status: uint64)
{
    return status <= 99 || (status >= 200 && status != 204 && status != 304);
}

export type Request = unit {
    request: RequestLine;
    message: Message(False, True, self.request.nl);

    on %done {
      set_uri(self.request.method, self.request.uri);
    }
};

export type Reply = unit {
    reply: ReplyLine;
    message: Message(reply_code_needs_body(self.reply.status), False, self.reply.nl);

    on %done {
    }
};

type Version = unit {
    :        /HTTP\//;
    number: /[0-9]+\.[0-9]*/;
};

export type RequestLine = unit {
    method:  Token;
    :        WhiteSpace;
    uri:     URI;
    :        WhiteSpace;
    version: Version {
      self.version.number = b"1.0"; # always downgrade to HTTP/1.0
    }
    nl :      NewLine;
};

on RequestLine::version %debug {
    print "request", self.method, "|", self.uri, "|", self.version.number;
    }

type ReplyLine = unit {
    version: Version;
    :        WhiteSpace;
    var status: uint64;
    status_raw:  Integer {
      self.status = self.status_raw.to_uint(); # generator bug workaround
    }
    :        OptionalWhiteSpace;
    reason:  RestOfLine;
    nl :     NewLine;
};

on ReplyLine::reason %debug {
    print "reply  ", self.version.number, "|", self.status, "|", self.reason;
    }

type Message = unit(body_default: bool, is_request: bool, newline: bytes) {
    proxied:    bytes &length=0 {
      if ( is_request )
          self.proxied = BinPAC::fmt (b"Connection-Proxied: true%s", (newline, 1));
    }
    headers:    list<Header(self)> &until_including($$.end == True);
    end_of_hdr: bytes &length=0;
    body:       Body(self, self.delivery_mode) if ( self.has_body );
#
    var content_length: uint64;
    var content_encoding: bytes;
    var content_type: tuple<bytes, bytes> = (b"TEXT", b"PLAIN");
    var content_type_parameter: bytes;
    var transfer_encoding: bytes;
    var multipart_boundary: bytes;
#
    var has_body: bool;
    var is_request: bool;
    var use_content_length: bool = True;
    var delivery_mode: DeliveryMode;
#
    on %init {
        self.has_body = body_default;
        self.is_request = is_request;
        # FIXME: This as &default doesn't work for some reason.
        self.delivery_mode = DeliveryMode::EndOfData;
        }

    on end_of_hdr {
        if ( self?.content_length && self.content_length > 0 )
            self.delivery_mode = DeliveryMode::Length;


    }
};

const HeaderName  = /[^:\r\n]*/;
const HeaderValue = /[^\r\n]*/;

type Header = unit(msg: Message) {
    var end: bool = False;

    name:    HeaderName &convert=$$.upper() {
      if ( |self.name| == 0 ) {
        self.end = True;
      }
    }
    : /:[\t ]*/ if ( ! self.end );
    content: HeaderValue if ( ! self.end ) {
        if ( self.name == b"CONTENT-LENGTH" ) {
            msg.content_length = self.content.to_uint();
            msg.has_body = True;
            }

        if ( self.name == b"TRANSFER-ENCODING" ) {
            msg.transfer_encoding = self.content;
            msg.has_body = True;
            }

        if ( self.name == b"CONTENT-ENCODING" )
            msg.content_encoding = self.content;

        if ( self.name == b"CONTENT-TYPE" ) {
            local ct: tuple<bytes,bytes> = self.content.split1(b";");
            local ty: tuple<bytes,bytes> = ct[0].split1(b"/");
            msg.content_type = (ty[0].strip().upper(), ty[1].strip().upper());
            msg.content_type_parameter = ct[1].strip();
            }

        if ( self.name == b"HOST" )
            set_host(self.content);

        if ( self.name == b"CONNECTION" )
            self.content = b"close";   # I don't want to support keep-alive from servers.

        }
    : NewLine;

};

type Body = unit(msg: Message, delivery_mode: DeliveryMode) {
    data: bytes &eod;
    #switch ( delivery_mode ) {
    #  DeliveryMode::EndOfData -> data : bytes &eod;
    #  DeliveryMode::Length    -> data : bytes &length=msg.content_length;
    #};
};
